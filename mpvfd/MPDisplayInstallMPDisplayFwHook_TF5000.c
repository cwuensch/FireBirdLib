#include "FBLib_mpvfd.h"

#ifndef _TMS_

// The symbol map contains the 17-segment representation of ASCII characters
// used for the 8-symbol display.
// The MSB of each dword is the ASCII code. The 17 least significant bits
// of the dword represent the segments to be set.
// Segments mapping (bits 17 .. 0): a1 a2 f h i j b g1 g3 g2 e m l k c d1 d2
const dword symbolMap17[] =
{
  0x00000000, 0x01000000, 0x02000000, 0x03000000,
  0x04000000, 0x05000000, 0x06000000, 0x07000000,
  0x08000000, 0x09000000, 0x0a000000, 0x0b000000,
  0x0c000000, 0x0d000000, 0x0e000000, 0x0f000000,
  0x10000000, 0x11000000, 0x12000000, 0x13000000,
  0x14000000, 0x15000000, 0x16000000, 0x17000000,
  0x18000000, 0x19000000, 0x1a000000, 0x1b000000,
  0x1c000000, 0x1d000000, 0x1e000000, 0x1f000000,
  0x20000000, 0x21000810, 0x22001400, 0x23002BA8,
  0x2401D397, 0x25004924, 0x26015253, 0x27001000,
  0x28014042, 0x29008405, 0x2A003bb8, 0x2B001390,
  0x2C000220, 0x2D000380, 0x2E000002, 0x2F000920,
  0x3001CD67, 0x31001110, 0x320187C3, 0x33018787,
  0x34004784, 0x3501C387, 0x3601C3C7, 0x37018404,
  0x3801C7C7, 0x3901C787, 0x3A000202, 0x3B001020,
  0x3C000908, 0x3D000383, 0x3E002120, 0x3F01C590,
  0x40018657, 0x4101C7C4, 0x42019597, 0x4301C043,
  0x44019417, 0x4501C3C3, 0x4601C3C0, 0x4701C0C7,
  0x480047C4, 0x49019113, 0x4A000407, 0x4B004B48,
  0x4C004043, 0x4D006D44, 0x4E00654C, 0x4F01C447,
  0x5001C7C0, 0x5101C44F, 0x5201C7C8, 0x5301C387,
  0x54019110, 0x55004447, 0x56004960, 0x5700456C,
  0x58002928, 0x59002910, 0x5A018923, 0x5B014042,
  0x5C002108, 0x5D008405, 0x5E01C400, 0x5F000003,
  0x60001000, 0x61000353, 0x62004252, 0x63000242,
  0x64001352, 0x65000262, 0x66014340, 0x6700008D,
  0x68004350, 0x69000810, 0x6A001012, 0x6B001918,
  0x6C001111, 0x6D0002D4, 0x6E000250, 0x6F000252,
  0x70009590, 0x71015311, 0x72000340, 0x73000089,
  0x74001391, 0x75000052, 0x76000060, 0x7700007C,
  0x780003A8, 0x79001485, 0x7A000322, 0x7B009211,
  0x7C001110, 0x7D011092, 0x7E000100, 0x7F000000
};

// The symbol map contains the 14-segment representation of digit characters
// used for the 4-symbol display.
// The 14 least significant bits of the word represent the segments to be set.
// Segment mapping (bits 13 .. 0): a f h i j b g1 g2 e m l k c d
const word symbolMap14[] =
{
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0x10
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0x20
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00c0, 0x0000, 0x0000,
  0x3123, 0x0408, 0x21E1, 0x21C3, 0x11C2, 0x30C3, 0x30E3, 0x2102, // 0x30
  0x31E3, 0x31C3, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x31e2, 0x32e3, 0x3021, 0x250b, 0x30a1, 0x30a0, 0x3063, // 0x40
  0x11e3, 0x2409, 0x0103, 0x12a4, 0x1021, 0x1b22, 0x1926, 0x3123,
  0x31e0, 0x3127, 0x31e4, 0x30c3, 0x2408, 0x1123, 0x1230, 0x1136, // 0x50
  0x0a14, 0x0a08, 0x2211, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x31e2, 0x32e3, 0x3021, 0x250b, 0x30a1, 0x30a0, 0x3063, // 0x60
  0x11e3, 0x2409, 0x0103, 0x12a4, 0x1021, 0x1b22, 0x1926, 0x3123,
  0x31e0, 0x3127, 0x31e4, 0x30c3, 0x2408, 0x1123, 0x1230, 0x1136, // 0x70
  0x0a14, 0x0a08, 0x2211, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

// segmentMap17 describes the actual location of the bit representing a symbol
// segment in the 48-byte data block.
// data organization:
// 8 positions
// 17 bits per position (i.e. symbol)
// to be mapped to an offset in the data block and a bit mask
const byte segmentMap17[8][17][2] =
{
  {
    {37,0x80},{37,0x20},{36,0x80},{36,0x08},{36,0x02},{36,0x20},
    {35,0x02},{35,0x80},{35,0x08},{35,0x20},{33,0x02},{34,0x08},
    {34,0x20},{34,0x02},{34,0x80},{33,0x20},{33,0x08}
  },
  {
    {21,0x80},{21,0x20},{20,0x80},{20,0x08},{20,0x02},{20,0x20},
    {19,0x02},{19,0x80},{19,0x08},{19,0x20},{17,0x02},{18,0x08},
    {18,0x20},{18,0x02},{18,0x80},{17,0x20},{17,0x08}
  },
  {
    {21,0x40},{21,0x10},{20,0x40},{20,0x04},{20,0x01},{20,0x10},
    {19,0x01},{19,0x40},{19,0x04},{19,0x10},{17,0x01},{18,0x04},
    {18,0x10},{18,0x01},{18,0x40},{17,0x10},{17,0x04}
  },
  {
    {41,0x20},{41,0x08},{40,0x20},{40,0x02},{41,0x80},{40,0x08},
    {40,0x80},{39,0x20},{39,0x02},{39,0x08},{38,0x80},{38,0x02},
    {38,0x08},{39,0x80},{38,0x20},{37,0x08},{37,0x02}
  },
  {
    {41,0x10},{41,0x04},{40,0x10},{40,0x01},{41,0x40},{40,0x04},
    {40,0x40},{39,0x10},{39,0x01},{39,0x04},{38,0x40},{38,0x01},
    {38,0x04},{39,0x40},{38,0x10},{37,0x04},{37,0x01}
  },
  {
    {25,0x20},{25,0x08},{24,0x20},{24,0x02},{25,0x80},{24,0x08},
    {24,0x80},{23,0x20},{23,0x02},{23,0x08},{22,0x80},{22,0x02},
    {22,0x08},{23,0x80},{22,0x20},{21,0x08},{21,0x02}
  },
  {
    {25,0x10},{25,0x04},{24,0x10},{24,0x01},{25,0x40},{24,0x04},
    {24,0x40},{23,0x10},{23,0x01},{23,0x04},{22,0x40},{22,0x01},
    {22,0x04},{23,0x40},{22,0x10},{21,0x04},{21,0x01}
  },
  {
    {37,0x40},{37,0x10},{36,0x40},{36,0x04},{36,0x01},{36,0x10},
    {35,0x01},{35,0x40},{35,0x04},{35,0x10},{33,0x01},{34,0x04},
    {34,0x10},{34,0x01},{34,0x40},{33,0x10},{33,0x04}
  }
};

// This segmentMap14 describes the actual location of the bit representing a symbol
// segment in the 48-byte data block.
// data organization:
// 4 positions
// 14 bits per position (i.e. symbol)
// to be mapped to an offset in the data block and a bit mask
const byte segmentMap14[4][14][2] =
{
  {
    {3,0x40},{2,0x04},{2,0x01},{3,0x80},{2,0x02},{2,0x08},{2,0x20},
    {2,0x10},{1,0x04},{2,0x80},{1,0x01},{2,0x40},{1,0x02},{1,0x08},
  },
  {
    {4,0x01},{4,0x10},{4,0x04},{4,0x02},{4,0x08},{4,0x20},{4,0x80},
    {4,0x40},{3,0x10},{3,0x02},{3,0x04},{3,0x01},{3,0x08},{3,0x20},
  },
  {
    {6,0x02},{6,0x20},{6,0x08},{6,0x04},{6,0x10},{6,0x40},{5,0x01},
    {6,0x80},{5,0x20},{5,0x04},{5,0x08},{5,0x02},{5,0x10},{5,0x40},
  },
  {
    {8,0x01},{8,0x10},{8,0x04},{8,0x02},{8,0x08},{8,0x20},{8,0x80},
    {8,0x40},{7,0x10},{7,0x20},{7,0x04},{7,0x01},{7,0x08},{7,0x20},
  }
};

// this mask contains all bits excluding the bits which form the
// symbols in the 8-symbol display
const byte longStringMask[48] =
{
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// this mask contains all bits excluding the bits which form the
// symbols in the 4-symbol display
const byte shortStringMask[48] =
{
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

// this mask contains all bits excluding the bits which form the
// symbols in both the 8-symbol display and the 4-symbol display
const byte bothStringsMask[48] =
{
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// this mask contains all segment bits
const byte fullStringsMask[48] =
{
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
  0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff
};

byte      StringsMask [48];

// the VFD display function directly outputs the provided data
// it takes a pointer to an array of 48 bytes
union VFDDISP VFDDisplay;
DisplayFunc sendToVfdDisplay = NULL;

// the pointer to the original FW function responsible for the display output
dword            *pFwSendToVfdDisplay = NULL;
bool             bFwHookInstalled = FALSE;

// This function installs the firmware hook. When called for the first time it
// initializes the code wrapper required to switch from the TAP context to the
// firmware context. In addition, the hook function is provided with the absolute
// address of the global data and the return (jump-back) address.
bool MPDisplayInstallMPDisplayFwHook (void)
{
  if (!LibInitialized) InitTAPex ();
  if (!LibInitialized) return FALSE;

  // check for the MasterPiece system ID
  if (!isMasterpiece())
  {
    DBG_PRINT("MPDisplayLib: Unsupported system.\n");
    return FALSE;
  }

  DBG_PRINT ("MPDisplayLib: fwHook = %08x\n",fwHook);

  // init global data
  VFDDisplay.Segments.Colon = FALSE;
  VFDDisplay.Segments.AnteMeridiem = FALSE;
  VFDDisplay.Segments.PostMeridiem = FALSE;
  VFDDisplay.Memory.displayMode = DISPLAY_FW;
  VFDDisplay.Memory.shortStringMask = shortStringMask;
  VFDDisplay.Memory.longStringMask = longStringMask;
  VFDDisplay.Memory.bothStringsMask = bothStringsMask;
  VFDDisplay.Memory.fullStringsMask = fullStringsMask;

  if(!bFwHookInstalled)
  {

    if(pFwSendToVfdDisplay == NULL)
    {
      // display function address has not yet been determined
      dword *pBuffer;

      // update instructions in the hook function with the actual addresses
      pBuffer = (dword*)fwHook;
      // validate the expected intruction order
      if((pBuffer[0] != LUI_A1_CMD) || (pBuffer[1] != OR_A1_CMD))
      {
        DBG_PRINT("MPDisplayLib: Unexpected instruction order.\n");
        return FALSE;
      }

      DBG_PRINT ("MPDisplayLib: combineVfdData = %08x\n", combineVfdData);
      DBG_PRINT("MPDisplayLib: VFDDisplay = %08x\n", &VFDDisplay);

      // insert the global data address
      pBuffer[0] = LUI_A1_CMD | (((dword)&VFDDisplay >> 16) & 0xffff);
      pBuffer[1] = OR_A1_CMD | ((dword)&VFDDisplay & 0xffff);

      // determine the address of the FW display function
      pFwSendToVfdDisplay = findSendToVfdDisplay((dword*)0x80000000, 0x10000);
      if(pFwSendToVfdDisplay == NULL)
      {
        DBG_PRINT("MPDisplayLib: Display function not found.\n");
        return FALSE;
      }

      // copy the instruction which will be replaced with the call to the hook
      pBuffer = (dword*)exitHook;
      pBuffer[0] = pFwSendToVfdDisplay[0];
      pBuffer[1] = pFwSendToVfdDisplay[1];
      // insert the return jump into exitHook()
      pBuffer[2] = JMP_CMD | REL_ADDR((pFwSendToVfdDisplay + 2));
      pBuffer[3] = NOP_CMD;

      // init code wrapper
      sendToVfdDisplay = (DisplayFunc)initCodeWrapper(pFwSendToVfdDisplay);
      if(sendToVfdDisplay == NULL)
      {
        DBG_PRINT("MPDisplayLib: Failed to initialize the code wrapper.\n");
        pFwSendToVfdDisplay = NULL;
        return FALSE;
      }
    }

    // install the hook into FW code
    pFwSendToVfdDisplay[0] = JMP_CMD | REL_ADDR(((dword*)fwHook)); // insert jump to the hook
    pFwSendToVfdDisplay[1] = NOP_CMD;

    bFwHookInstalled = TRUE;

    return TRUE;
  }
  else
  {
    // already installed
    DBG_PRINT("MPDisplayLib: Hook already installed\n");
    return FALSE;
  }
}

#endif
